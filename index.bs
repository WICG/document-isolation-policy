<pre class="metadata">
Title: Document-Isolation-Policy
Status: CG-DRAFT
Group: WICG
ED: https://github.com/WICG/document-isolation-policy
Repository: https://github.com/WICG/document-isolation-policy
Shortname: document-isolation-policy
Level: None
Editor: Camille Lamy, Google, clamy@google.com
Abstract:
  This proposal explores a new header, "Document-Isolation-Policy", that
  enables crossOriginIsolation for the document, without relying on COOP and
  COEP. In turns, this gives access to COI-gated APIs such as SharedArrayBuffers.
Indent: 2
Work Status: exploring
Boilerplate: omit conformance
Markup Shorthands: css off, markdown on
WPT Display: inline
</pre>

<pre boilerplate="copyright">&copy;2024, Google, Inc. All rights reserved.</pre>

<pre class="biblio">
{
  "spectre": {
    "authors": [
      "Paul Kocher",
      "Jann Horn",
      "Anders Fogh",
      "Daniel Genkin",
      "Daniel Gruss",
      "Werner Haas",
      "Mike Hamburg",
      "Moritz Lipp",
      "Stefan Mangard",
      "Thomas Prescher",
      "Michael Schwarz",
      "Yuval Yarom"
    ],
    "href": "https://spectreattack.com/spectre.pdf",
    "title": "Spectre Attacks: Exploiting Speculative Execution"
  },

  "explainer": {
    "authors": [
      "Camille Lamy"
    ],
    "href": "https://github.com/WICG/document-isolation-policy",
    "title": "Document-Isolation-Policy explainer"
  },

  "WhyCoopCoep": {
    "authors": [
      "Eiji Kitamura",
      "Demenic Denicola"
    ],
    "href": "https://web.dev/why-coop-coep/",
    "title": "Why you need \"cross-origin isolated\" for powerful features"
  }
}
</pre>

<pre class="anchors">
urlPrefix: https://html.spec.whatwg.org/C/; spec: html
  text: agent cluster key; type:dfn; url:agent-cluster-key
  text: browsing context; type:dfn; url:browsing-context
  text: browsing context group; type:dfn; url:browsing-context-group
  text: policy container; type: dfn; url: policy-container
  text: concrete; type:dfn; url:cross-origin-isolation-concrete
  text: create a new browsing context and document; type:dfn; url:creating-a-new-browsing-context
  text: create and initialize a document object; type:dfn; url:initialise-the-document-object
  text: creating a new browsing context group and document; type:dfn; url:creating-a-new-browsing-context-group-and-document
  text: creating a new top-level browsing context and document; type:dfn; url:creating-a-new-top-level-browsing-context
  text: create a new top-level browsing context and document; type:dfn; url:creating-a-new-top-level-browsing-context
  text: create a new top-level traversable; type:dfn; url:creating-a-new-top-level-traversable
  text: coep-unsafe-none; type: dfn; url: coep-unsafe-none
  text: cross-origin isolation mode; type:dfn; url: bcg-cross-origin-isolation
  text: embedder-policy-report-only-value; type: dfn; url: embedder-policy-report-only-value
  text: embedder-policy-value; type:dfn; url:embedder-policy-value
  text: embedder-policy-value-2; type:dfn; url:embedder-policy-value-2
  text: environment; type:dfn; url:environment
  text: Integration with the JavaScript agent cluster formalism; type:dfn; url:integration-with-the-javascript-agent-cluster-formalism
  text: is origin-keyed; type:dfn; url:is-origin-keyed
  text: loading web pages supporting concepts; type:dfn; url:loading-web-pages-supporting-concepts
  text: logical; type:dfn; url:cross-origin-isolation-logical
  text: obtain a browsing context to use for a navigation response; type:dfn; url:obtain-browsing-context-navigation
  text: obtaining a similar-origin window agent; type:dfn; url:obtain-similar-origin-window-agent
  text: origin; type:dfn; url:concept-origin
  text: same-origin-plus-coep; type:dfn; url:coop-same-origin-plus-coep

urlPrefix: https://httpwg.org/specs/rfc8941.html; spec: Structured-Fields
  text: structured headers; type:dfn; url:specify

urlPrefix: https://fetch.spec.whatwg.org/; spec: Fetch
  text: cross-origin-resource-policy; type:dfn; url:http-cross-origin-resource-policy
  text: cross-origin resource policy internal check; type:dfn; url:cross-origin-resource-policy-internal-check
  text: http-network-or-cache fetch; type:dfn; url:concept-http-network-or-cache-fetch
  text: queue a cross-origin embedder policy corp violation report; type:dfn; url:queue-a-cross-origin-embedder-policy-corp-violation-report
  text: request-includes-credentials; type:dfn; url:response-request-includes-credentials
  text: redirect-tainted origin; type:dfn; url:concept-request-tainted-origin

</pre>

<pre class="link-defaults">
  spec:fetch; type:dfn; for:/; text:response
  spec:fetch; type:dfn; text:client
  spec:fetch; type:dfn; text:current url
  spec:fetch; type:dfn; text:mode
  spec:fetch; type:dfn; for:Request; text:request
  spec:fetch; type:dfn; for:response; text:header list
  spec:html; type:dfn; for:/; text:origin
  spec:html; type:dfn; for:Window; text:browsing context
  spec:html; type:dfn; text:environment
  spec:html; type:dfn; for:environment settings object; text:global object
  spec:url; type:dfn; for:/; text:url
  spec:url; type:dfn; text:scheme
</pre>

<style>
.monkey-patch {
    padding: .5em;
    border: thin solid #ddd;
    border: thin solid 1px;
    border-radius: .5em;
    margin: .5em calc(-0.5em - 1px);
    background-color: rgba(255, 255, 0, 0.03);
    backdrop-filter: blur(5px);
    box-shadow: 0px 5px 5px 0px rgba(0, 0, 0, 0.05);
}

.brief {
  line-height: 10%;
}

.customHighlight {
  padding-top:9px ;
  padding-bottom:9px ;
  background-color: rgba(255,255,0,0.3)
}

</style>

Introduction { #introduction }
============

<em>This section is not normative.</em>

Recommended readings {#recommended-readings}
--------------------
- The [[explainer]] for Document-Isolation-Policy.
- The [[Spectre]] vulnerability.
- The [:Cross-Origin-Opener-Policy:] (COOP) section of the HTML spec.
- The [:Cross-Origin-Embedder-Policy:] (COEP) section of the HTML spec.
- How and why [:Cross-Origin-Opener-Policy:] (COOP) and
  [:Cross-Origin-Embedder-Policy:] (COEP) are granting the
  [=environment settings object/cross-origin isolated capability=]. See [[WhyCoopCoep]].

# Integration with HMTL # {#dip-html}

This section defines a monkey-patch over [[!HTML]].

## Supporting concepts when loading web pages ## {#dip-supporting-concepts}

### Cross-origin-opener-policies ### {#dip}

Modify the definition of "[=same-origin-plus-coep=]":

<div class="monkey-patch">

This behaves the same as "same-origin", with the addition that it sets the
(new) [=top-level browsing context=]'s [=browsing context group|group=]'s
[=browsing context group/agent cluster cross-origin isolation key=]'s [=cross-origin
isolation mode=] to one of "[=logical=]" or "[=concrete=]".

</div>

#### Browsing context group switches due to cross-origin opener policy #### {#dip-bcg-switch}

Modify step 4 of the [=obtain a browsing context to use for a navigation response=] algorithm:

<div class="monkey-patch">

4. If *navigationCOOP*'s value is "[=same-origin-plus-COEP=]", then:
  1. Let *crossOriginIsolationMode* be either "[=logical=]" or "[=concrete=]".
     The choice of which is implementation-defined.
  2. Set *newBrowsingContext*'s [=browsing context group|group=]'s
     [=browsing context group/agent cluster cross-origin isolation key=] to
     {*coopEnforcementResult*'s [=origin=], *crossOriginIsolationMode*}. 

</div>

### Document Isolation Policies ### {#dip-dip}

Add a new subsection to the [=loading web pages supporting concepts=] section
of the HTML spec.

<div class="monkey-patch">

A <dfn id="dip-value">document isolation policy value</dfn> is one of three
strings that controls [=agent cluster=] allocation and the fetching of
cross-origin resources without explicit permission from resource owners.

* "<dfn for="document isolation policy value" id="dip-none">none</dfn>":
  This is the default value. When this value is used, cross-origin resources
  can be fetched without giving explicit permission through the [=CORS
  protocol=] or the [:Cross-Origin-Resource-Policy:] header. The document is
  assigned to a non cross-origin isolated [=agent cluster=].

* "<dfn for="document isolation policy value" id="dip-isolate-and-require-corp">isolate-and-require-corp</dfn>":
  When this value is used, fetching cross-origin resources requires the
  server's explicit permission through the [=CORS protocol=] or the
  [:Cross-Origin-Resource-Policy:] header. The document is also assigned to a
  cross-origin isolated [=agent cluster=].

* "<dfn for="document isolation policy value" id="dip-isolate-and-credentialless">isolate-and-credentialless</dfn>":
  When this value is used, fetching cross-origin no-CORS resources omits
  credentials. In exchange, an explicit [:Cross-Origin-Resource-Policy:]
  header is not required. Other requests sent with credentials require the
  server's explicit permission through the [=CORS protocol=] or the
  [:Cross-Origin-Resource-Policy:] header. The document is also assigned to a
  cross-origin isolated [=agent cluster=].

A <dfn id="dip-struct">document isolation policy</dfn> consists of:
* A <dfn for="document isolation policy" id="dip-struct-value">value</dfn>, which is a [=document
  isolation policy value=], initially "[=none=].
* A <dfn for="document isolation policy" id="dip-reporting-endpoint">reporting endpoint</dfn>, initially the
  empty string.
* A <dfn for="document isolation policy" id="dip-report-only-value">report-only value</dfn>, which is a
  [=document
  isolation policy value=], initially "[=none=].
* A <dfn for="document isolation policy" id="dip-report-only-endpoint">report-only reporting endpoint</dfn>,
  initially the empty string.

To <dfn abstract-op id="obtain-coi-key">obtain a cross-origin agent cluster isolation
key</dfn> given null or a [=/document isolation policy=]
*documentIsolationPolicy* and an [=origin=] *origin*:
1. If *documentIsolationPolicy* is null, return null.
2. If *documentIsolationPolicy*'s [=document isolation policy/value=] is
   "[=none=]", then return null.
3. Let *crossOriginIsolationMode* be either "[=logical=]" or "[=concrete=]".
   The choice of which is implementation-defined.
4. Let *crossOriginIsolationKey* be a new [=/agent cluster
   cross-origin isolation key=].
5. Set *crossOriginIsolationKey* to {*origin*, *crossOriginIsolationMode*}. 
6. Return *crossOriginIsolationKey*.

#### The headers #### {#dip-headers}

The '<dfn http-header id="dip-header">Document-Isolation-Policy</dfn>' and
'<dfn http-header id="dip-report-only-header">Document-Isolation-Policy-Report-Only</dfn>'
HTTP response headers allow a server to declare a [=/document isolation
policy=] for a [=/document=]. These headers are [=structured headers=] whose values
must be [=token=].

The valid [=token=] values are the [=document isolation policy
values=]. The token may also have attached [=parameters=]; of these, the
"report-to" parameter can have a [=valid URL string=] identifying an
appropriate reporting endpoint.

To <dfn abstract-op id="obtain-dip">obtain a document isolation policy</dfn> given a
[=response=] *response* and an [=environment=] *environment*:

1. Let *policy* be a new [=/document isolation policy=].
2. If *environment* is a [=non-secure context=], then return *policy*.
3. Let *parsedItem* be the result of [=getting a structured field value=] with
   `Document-Isolation-Policy` and "item" from *response*'s [=header list=].
4. If *parsedItem* is non-null:
   1. If *parsedItem*[0] is
      "[=isolate-and-require-corp=]" or
      "[=isolate-and-credentialless=]", set
      *policy*'s [=document isolation policy/value=] to *parsedItem*[0].
   2. If *parsedItem*[1]["report-to"] [=map/exists=], then set *policy*'s
      [=reporting endpoint=] to
      *parsedItem*[1]["report-to"].
5. Set *parsedItem* be the result of [=getting a structured field value=] with
   `Document-Isolation-Policy-Report-Only` and "item" from *response*'s
   [=header list=].
6. If *parsedItem* is non-null:
   1. If *parsedItem*[0] is
      "[=isolate-and-require-corp=]" or
      "[=isolate-and-credentialless=]", set
      *policy*'s [=document isolation policy/report-only value=] to
      *parsedItem*[0].
   2. If *parsedItem*[1]["report-to"] [=map/exists=], then set
      *policy*'s [=report-only reporting endpoint=] to
      *parsedItem*[1]["report-to"].
7. Return policy.

</div>

### Policy containers ### {#dip-policy-containers}

Add the following members to the [=policy container=] struct:

<div class="monkey-patch">

* A <dfn for="policy container" id="policy-container-dip">document isolation policy</dfn>, which is a
  [=/document isolation policy=]. It is initially a new
  [=/document isolation policy=].

* An <dfn for="policy container" id="policy-container-coi-key">agent cluster cross-origin isolation
  key</dfn>, which is null or an [=/agent cluster
  cross-origin isolation key=]. It is initially null. This
  [=/agent cluster cross-origin isolation key=] is based
  on the [=/document isolation policy=] of the document. It overrides the 
  [=browsing context group/agent cluster cross-origin isolation key=] stored in the
  [=browsing context group=].

</div>

Add step 5 and 6 to the [=clone a policy container=] algorithm:

<div class="monkey-patch">

5. Set *clone*'s [=policy container/document isolation policy=] to a copy
   of *policyContainer*'s [=policy container/document isolation policy=].

6. Set *clone*'s [=policy container/agent cluster cross-origin
   isolation key=] to a copy of *policyContainer*'s
   [=policy container/agent cluster cross-origin isolation key=].

</div>

Add step 6 and 7 to the [=create a policy container from a fetch response =]:

<div class="monkey-patch">

6. If *environment* is non-null, then set *result*'s
   [=policy container/document isolation policy=] to the result of
   [$obtain a document isolation policy|obtaining a document isolation policy$] given *response* and
   *environment*.

7. Set *result*'s [=policy container/agent cluster cross-origin
   isolation key=] to the result of [$obtain a cross-origin
   agent cluster isolation key|obtaining a cross-origin
   agent cluster isolation key$] given *result*'s [=policy container/document isolation
   policy=] and *response*'s [=URL=]'s [=origin=].

</div>


## Browsing contexts ## {#dip-browsing-contexts}

### Browsing contexts ### {#dip-bc}

<div class="monkey-patch">

Add a step 5 to the [=create a new browsing context and document=] algorithm:

5. Let *creatorAgentClusterCOIKey* be null.

</div>

Add a step 5.4 to the [=create a new browsing context and document=] algorithm:

<div class="monkey-patch">

5.4 Set *creatorAgentClusterCOIKey* to *creator*'s [=policy container=]'s
[=policy container/agent cluster cross-origin isolation key=].

</div>

Modify step 9 of the [=create a new browsing context and document=] algorithm:

<div class="monkey-patch">

9. Let *agent* be the result of obtaining a similar-origin window agent given
   *origin*, *group*, false, and *creatorAgentClusterCOIKey*.

</div>

### Grouping of browsing contexts ### {#dip-grouping-of-browsing-contexts}

Remove the following line:

<div class="monkey-patch">

A [=browsing context group=] has a cross-origin isolation mode, which is a
[=cross-origin isolation mode=]. It is initially "none".

</div>

Add the following line:

<div class="monkey-patch">

A [=browsing context group=] has an <dfn for="browsing context group" id="bcg-coi-key">agent cluster
cross-origin isolation key</dfn>, which is null or an
[=/agent cluster cross-origin isolation key=] . It is
initially null. It is set by [:Cross-Origin-Opener-Policy:], and is the default
[=/agent cluster cross-origin isolation key=] for
documents inside the [=browsing context group=]. However, it can be overriden by the policy container's
[=policy container/agent cluster cross-origin
isolation key=] when a document has a [=/document isolation policy=].

</div>

## Document lifecycle ## {#dip-document-lifecycle}

### Shared document creation infrastructure ### {#dip-document-creation}

Modify step 8.4 of the [=create and initialize a Document object=] algorithm:

<div class="monkey-patch">

Let *agent* be the result of [=obtaining a similar-origin window agent=] given
*navigationParams*'s [=origin=], *browsingContext*'s [=browsing context
group|group=], *requestsOAC*, and *navigationParams*'s [=policy container=]'s
[=policy container/agent cluster cross-origin isolation key=].

</div>

## Agents and agent clusters ## {#dip-agent-clusters}

Add the following to the [=Integration with the JavaScript agent cluster
formalism=]:

<div class="monkey-patch">

An <dfn id="coi-agent-cluster-key">agent cluster cross-origin isolation
key</dfn> is a [=tuple=] of an [=origin=] and a [=cross-origin isolation
mode=].

</div>

Change the definition of the [=agent cluster key=]:

<div class="monkey-patch">

An [=agent cluster key=] is either a [=site=], or a [=tuple origin=], or a
[=tuple=] of a [=tuple origin=] and an [=/agent cluster
cross-origin isolation key=].

</div>

Modify the [=obtain a similar-origin window agent=] algorithm definition:

<div class="monkey-patch">

To [=obtain a similar-origin window agent=], given an [=origin=] *origin*, a
[=browsing context group=] *group*, a boolean *requestsOAC*, and null or an
[=/agent cluster cross-origin isolation key=]
*agentClusterCOIKey*, run these steps:

</div>

Modify step 3 of the [=obtain a similar-origin window agent=] algorithm:
<div class="monkey-patch">

3. If *agentClusterCOIKey* is not *null*, then set *key* to {*origin*,
   *agentClusterCOIKey*}.
4. Otherwise, if *group's* [=browsing context group/agent cluster cross-origin isolation
   key=] is not *null*, then set *key* to {*origin*, *group's* [=browsing context group/agent
   cluster cross-origin isolation key=]}.

</div>

Modify steps 6.2 and 6.3 of the [=obtain a similar-origin window agent=] algorithm:

<div class="monkey-patch">

6.2 If *key* has an [=/agent cluster cross-origin
isolation key=], set *agentCluster*'s [=cross-origin isolation mode=] to
*key*'s [=/agent cluster cross-origin isolation key=]'s
[=cross-origin isolation mode=].

6.3 Set *agentCluster*'s [=is origin-keyed=] to false if *key* equals *site*; otherwise true.

</div>

# Integration with Fetch # {#dip-fetch}

This section defines a monkey-patch over [[!Fetch]].

## Requests ## {#dip-requests}

Add a new algorithm to the [=Requests=] part of Fetch:

<div class="monkey-patch">

To check if <dfn>Document-Isolation-Policy allows credentials</dfn>, given a
[=request=] *request*, run these steps:
1. If *request*’s [=mode=] is not "no-cors", then return true.
2. If *request*’s [=client=] is null, then return true.
3. If *request*’s [=client=]’s [=policy container=]’s
   [=policy container/document isolation policy=]’s [=document isolation policy value|value=] is not
   "[=isolate-and-credentialless=]", then return true.
4. If *request*’s [=origin=] is [=same origin=] with *request*’s [=current
   URL=]’s [=origin=] and *request* does not have a [=redirect-tainted origin=],
   then return true.
5. Return false.

</div>

## 'Cross-Origin-Resource-Policy' header ## {#dip-corp}

Add a new enum definition to the [:Cross-Origin-Resource-Policy:] section of Fetch:

<div class="monkey-patch">

A <dfn id="corp-check-result">cross-origin resource policy internal check result</dfn>
is one of five values:
* "<dfn for="cross-origin resource policy internal check result" id="corp-check-allowed">allowed</dfn>"
* "<dfn for="cross-origin resource policy internal check result" id="corp-check-blocked">blocked</dfn>"
* "<dfn for="cross-origin resource policy internal check result" id="corp-check-blocked-coep">blocked-by-coep</dfn>"
* "<dfn for="cross-origin resource policy internal check result" id="corp-check-blocked-dip">blocked-by-dip</dfn>"
* "<dfn for="cross-origin resource policy internal check result" id="corp-check-blocked-coep-dip">blocked-by-coep-and-dip</dfn>"

</div>

Modify the [=cross-origin resource policy check=] algorithm:

<div class="monkey-patch">

4. Let *documentIsolationPolicy* be *settingsObject*’s [=policy container=]’s
   [=policy container/document isolation policy=].
5. Let *reportOnlyCheck* be the the result of the [=cross-origin resource
   policy internal check=] with *origin*,  *embedderPolicy*’s
   [=embedder-policy-report-only-value|report only value=],
   *documentIsolationPolicy*’s [=document isolation policy/report-only value=],
   *response*, and *forNavigation*. 
6. If *reportOnlyCheck* is "[=blocked-by-coep=]" or
   "[=blocked-by-coep-and-dip=]", then [=queue a
   cross-origin embedder policy CORP violation report=] with *response*,
   *settingsObject*, *destination*, and true.
7. If *reportOnlyCheck* is "[=blocked-by-dip=]" or
   "[=blocked-by-coep-and-dip=]", then [=queue a
   document isolation policy CORP violation report=] with *response*,
   *settingsObject*, *destination*, and true.
8. Let *check* be the the result of the [=cross-origin resource
   policy internal check=] with *origin*,  *embedderPolicy*’s
   [=embedder-policy-value-2|value=], *documentIsolationPolicy*’s
   [=document isolation policy/value|report value=], *response*, and *forNavigation*. 
9. If *check* is "[=allowed=]", then return **allowed**.
10. If *check* is "[=blocked-by-coep=]" or
    "[=blocked-by-coep-and-dip=]", then [=queue a
    cross-origin embedder policy CORP violation report=] with *response*,
    *settingsObject*, *destination*, and false.
11. If *reportOnlyCheck* is "[=blocked-by-dip=]" or
    "[=blocked-by-coep-and-dip=]", then [=queue a
    document isolation policy CORP violation report=] with *response*,
    *settingsObject*, *destination*, and false.
12. Return **blocked**.

</div>

Modify the [=cross-origin resource policy internal check=] algorithm definition:

<div class="monkey-patch">

To perform a [=cross-origin resource policy internal check=], given an [=origin=]
*origin*, an [=embedder policy value=] *embedderPolicyValue*, a
[=/document isolation policy value=] *documentIsolationPolicyValue*, a
[=response=] *response*, and a boolean *forNavigation*, run these steps:

</div>

Modify the [=cross-origin resource policy internal check=] algorithm:

<div class="monkey-patch">

4. Let *checkResult* be a [=cross-origin resource policy
   internal check result=] with value "[=cross-origin resource policy internal check result/blocked=]".
6. If *policy* is null, then:
   1. Let *upgradeDueToCOEP* be false.
   2. Let *upgradeDueToDIP* be false.
   3. Switch on *embedderPolicyValue*:
      * "[=coep-unsafe-none|unsafe-none=]"
        1. Do nothing.
      * "[=credentialless=]"
        1. Set *upgradeDueToCOEP* to true if:
           * *response*’s [=request-includes-credentials=] is true, or
           * *forNavigation* is true.
      * "[=require-corp=]"
        1. Set *upgradeDueToCOEP* to true.
   4. Switch on *documentIsolationPolicyValue*:
      * "[=none=]"
        1. Do nothing.
      * "[=isolate-and-credentialless=]"
        1. Set *upgradeDueToDIP* to true if *response*’s
           [=request-includes-credentials=] is true.
      * "[=isolate-and-require-corp=]"
        1. Set *upgradeDueToDIP* to true.
   5. If *upgradeDueToCOEP* or *upgradeDueToDIP* is true, set *policy* to
      'same-origin'.
   6. If *upgradeDueToCOEP* is true, then:
      1. If *upgradeDueToDIP* is true, then set *checkResult* to
         "[=blocked-by-coep-and-dip=]".
      2. Otherwise, set *checkResult* to
         "[=blocked-by-coep=]". 
   7. Otherwise, if *upgradeDueToDIP* is true, then set *checkResult* to
         "[=blocked-by-dip=]".
7. Switch on *policy*:
   * null
   * `cross-origin`
     1. Set *checkResult* to "[=allowed=]".
   * `same-origin`
     1. If *origin* is [=same origin=] with *response*’s [=URL=]’s [=origin=],
        then set *checkResult* to "[=allowed=]".
   * `same-site`
     1. If all of the following are true
        * *origin* is [=schemelessly same site=] with *response*’s [=URL=]’s
          *origin*
        * *origin*’s [=scheme=] is "https" or *response*’s [=URL=]’s [=scheme=]
          is not "https"
     2. then set *checkResult* to "[=allowed=]".
8. Return *checkResult*.

</div>

Add a new algorithm to the [:Cross-Origin-Resource-Policy:] section of Fetch:

<div class="monkey-patch">

To <dfn>queue a document isolation policy CORP violation report</dfn>, given a
[=response=] *response*, an [=environment settings object=] *settingsObject*, a
string *destination*, and a boolean *reportOnly*, run these steps:
1. Let *endpoint* be *settingsObject*’s [=policy container=]’s
   [=policy container/document isolation policy=]’s
   [=report-only reporting endpoint=] if *reportOnly*
   is true and *settingsObject*’s [=policy container=]’s
   [=policy container/document isolation policy=]’s
   [=reporting endpoint=] otherwise.
2. Let *serializedURL* be the result of [=serializing a response URL for
   reporting=] with *response*.
3. Let *disposition* be "reporting" if reportOnly is true; otherwise "enforce".
4. Let *body* be a new object containing the following properties:
   <pre class=simpledef>
   "type": "corp"
   "blockedURL": serializedURL
   "destination": destination
   "disposition": disposition
   </pre>
5. [=Generate and queue a report=] for *settingsObject*’s [=global object=] given the "dip", *endpoint*, and *body*. 

</div>

## HTTP-network-or-cache fetch ## {#dip-http-fetch}

Add a step 8.5 to the [=HTTP-network-or-cache fetch=] algorithm:

<div class="monkey-patch">

5. If [=Document-Isolation-Policy allows credentials=] with *request* returns
   false, then set *includeCredentials* to false.

</div>

# Security considerations # {#dip-security}

<em>This section is not normative.</em>

Document-Isolation-Policy is a security API whose goal is to give access to
potentially dangerous APIs (like Shared Array Buffers) in a safe manner. In
order to do so, Document-Isolation-Policy relies on the user agent backing the
agent cluster separation with effective process separation. If the user agent
is not able to do so (e.g. it cannot support Out-of-Process Iframes), the user
agent should set a cross-origin isolation mode of "logical" for documents with
Document-Isolation-Policy. This will prevent the document from getting access
to the dangerous APIs gated behind cross-origin isolation.

This choice of cross-origin isolation mode should be a static choice made for
all origins on a user's machine, to avoid leaking the state of other documents on
the user's machine.

For a longer discussion of the threat model this API adresses, please refer to
the [[explainer]].

# Privacy considerations # {#dip-privacy}

<em>This section is not normative.</em>

No additional privacy concerns beyond the risks mentionned in the security
considerations section.
